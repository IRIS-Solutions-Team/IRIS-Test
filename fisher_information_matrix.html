
<!DOCTYPE html
  PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head>
      <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
   <!--
This HTML was auto-generated from MATLAB code.
To make changes, update the MATLAB code and republish this document.
      --><title>Simulate Fisher Info Matrix and Test Parameter Identification</title><meta name="generator" content="MATLAB 9.3"><link rel="schema.DC" href="http://purl.org/dc/elements/1.1/"><meta name="DC.date" content="2018-02-03"><meta name="DC.source" content="fisher_information_matrix.m"><style type="text/css">
html,body,div,span,applet,object,iframe,h1,h2,h3,h4,h5,h6,p,blockquote,pre,a,abbr,acronym,address,big,cite,code,del,dfn,em,font,img,ins,kbd,q,s,samp,small,strike,strong,sub,sup,tt,var,b,u,i,center,dl,dt,dd,ol,ul,li,fieldset,form,label,legend,table,caption,tbody,tfoot,thead,tr,th,td{margin:0;padding:0;border:0;outline:0;font-size:100%;vertical-align:baseline;background:transparent}body{line-height:1}ol,ul{list-style:none}blockquote,q{quotes:none}blockquote:before,blockquote:after,q:before,q:after{content:'';content:none}:focus{outine:0}ins{text-decoration:none}del{text-decoration:line-through}table{border-collapse:collapse;border-spacing:0}

html { min-height:100%; margin-bottom:1px; }
html body { height:100%; margin:0px; font-family:Arial, Helvetica, sans-serif; font-size:10px; color:#000; line-height:140%; background:#fff none; overflow-y:scroll; }
html body { margin-left:5%; margin-right:35% }
@media print {html body {margin-left:0px; margin-right:0px}}
html body td { vertical-align:top; text-align:left; }

h1 { padding:0px; margin:0px 0px 25px; font-family:Arial, Helvetica, sans-serif; font-size:1.5em; color:#d55000; line-height:100%; font-weight:normal; }
h2 { padding:0px; margin:0px 0px 8px; font-family:Arial, Helvetica, sans-serif; font-size:1.2em; color:#000; font-weight:bold; line-height:140%; border-bottom:1px solid #d6d4d4; display:block; }
h3 { padding:0px; margin:0px 0px 5px; font-family:Arial, Helvetica, sans-serif; font-size:1.1em; color:#000; font-weight:bold; line-height:140%; }

a { color:#005fce; text-decoration:none; }
a:hover { color:#005fce; text-decoration:underline; }
a:visited { color:#004aa0; text-decoration:none; }

p { padding:0px; margin:0px 0px 20px; }
img { padding:0px; margin:0px 0px 20px; border:none; }
p img, pre img, tt img, li img, h1 img, h2 img { margin-bottom:0px; } 

ul { padding:0px; margin:0px 0px 20px 23px; list-style:square; }
ul li { padding:0px; margin:0px 0px 7px 0px; }
ul li ul { padding:5px 0px 0px; margin:0px 0px 7px 23px; }
ul li ol li { list-style:decimal; }
ol { padding:0px; margin:0px 0px 20px 0px; list-style:decimal; }
ol li { padding:0px; margin:0px 0px 7px 23px; list-style-type:decimal; }
ol li ol { padding:5px 0px 0px; margin:0px 0px 7px 0px; }
ol li ol li { list-style-type:lower-alpha; }
ol li ul { padding-top:7px; }
ol li ul li { list-style:square; }

.content { font-size:1.2em; line-height:140%; padding: 20px; }

pre, code { font-size:12px; }
/* tt { font-size: 1.2em; } */
pre { margin:0px 0px 20px; }
pre.codeinput { padding:10px; border:1px solid #d3d3d3; background:#f7f7f7; }
pre.codeoutput { padding:10px 11px; margin:0px 0px 20px; color:#4c4c4c; }
pre.error { color:red; }

@media print { pre.codeinput, pre.codeoutput { word-wrap:break-word; width:1000%; } }

span.keyword { color:#0000FF }
span.comment { color:#228B22 }
span.string { color:#A020F0 }
span.untermstring { color:#B20000 }
span.syscmd { color:#B28C00 }

.footer { width:auto; padding:10px 0px; margin:25px 0px 0px; border-top:1px dotted #878787; font-size:0.8em; line-height:140%; font-style:italic; color:#878787; text-align:left; float:none; }
.footer p { margin:0px; }
.footer a { color:#878787; }
.footer a:hover { color:#878787; text-decoration:underline; }
.footer a:visited { color:#878787; }

table th { padding:7px 5px; text-align:left; vertical-align:middle; border: 1px solid #d6d4d4; font-weight:bold; }
table td { padding:7px 5px; text-align:left; vertical-align:top; border:1px solid #d6d4d4; }





  </style></head><body><div class="content"><h1>Simulate Fisher Info Matrix and Test Parameter Identification</h1><!--introduction--><p>Calculate estimates of the Fisher information matrix. The Fisher matrix is a property of the model itself, and is independent of any data. It represents the maximum amount of information one can hope for to find in the data in case the data are really generated by the model DGP.</p><p>Compare two approaches: a time-domain approach, and a frequency-domain approach. Use the singular value decomposition to learn more about which parameters (or combinations of them) are identified the best or the worst.</p><!--/introduction--><h2>Contents</h2><div><ul><li><a href="#1">Dependencies</a></li><li><a href="#2">Clear Workspace</a></li><li><a href="#3">Load Solved Model Object</a></li><li><a href="#4">Calculate Fisher Information Matrix</a></li><li><a href="#5">Singular Value Decomposition</a></li><li><a href="#6">Variables and Objects Created in This File</a></li></ul></div><h2 id="1">Dependencies</h2><p>Run the following m-files before this one:</p><div><ul><li><a href="read_model.html"><tt>read_model</tt></a></li></ul></div><h2 id="2">Clear Workspace</h2><p>Clear workspace, close all graphics figures, clear command window, and check the IRIS version.</p><pre class="codeinput">clear
close <span class="string">all</span>
clc
irisrequired <span class="string">20180131</span>
</pre><h2 id="3">Load Solved Model Object</h2><p>Load the solved model object built in <tt>read_model</tt>.</p><pre class="codeinput">load <span class="string">mat/read_model</span> <span class="string">m</span>
</pre><h2 id="4">Calculate Fisher Information Matrix</h2><p>The Fisher information matrix is a useful tools examining how much information can be recovered from the data to identify some of the model parameters (under the assumption that the model with its current parameters is the true DGP).</p><p>Compute the Fisher information matrix using two approaches: * a simulation method in the time domain. * an analytical method in the frequency domain.</p><p>The results are asymptotically equivalent. The actual differencies observed in this exercise arise because of</p><div><ul><li>sampling errors in the time domain,</li><li>the fact that the frequency domain approach assumes that the model variables follow a circular process (which is not true for samples of finite lenthgs).</li></ul></div><p>The differences and other approximation errors are though usually immaterial for detecting identification deficiencies.</p><pre class="codeinput">rng(0);

<span class="comment">% List of parameters for which for which the Fisher matrix will be</span>
<span class="comment">% evaluated.</span>
plist = {<span class="string">'chi'</span>, <span class="string">'xiw'</span>, <span class="string">'xip'</span>, <span class="string">'rhor'</span>, <span class="string">'kappap'</span>, <span class="string">'kappan'</span>, <span class="string">'std_Ey'</span>};

<span class="comment">% Set to a larger number in practice.</span>
numDraws = 100;

fprintf(<span class="string">'Resample %g times from calibrated model.\n'</span>, numDraws);

<span class="comment">% Simulate a total of numDraws artificial data, length 40 periods.</span>
d = resample(m, [ ], 1:40, numDraws, <span class="string">'deviation='</span>, false);
d = rmfield(d, <span class="string">'Wage'</span>);

disp(<span class="string">'Compute Hessians for each draw and average them'</span>)

[mloglik, s, F1] = diffloglik(m, d, 1:40, plist, <span class="keyword">...</span>
   <span class="string">'deviation='</span>, true, <span class="string">'relative='</span>, false, <span class="string">'progress='</span>, true);

F1 = mean(F1, 3);

disp(<span class="string">'Compute information matrix in frequency domain'</span>)
[F2, F2i, d] = fisher(m, 40, plist, <span class="keyword">...</span>
    <span class="string">'deviation='</span>, false, <span class="string">'exclude='</span>, {<span class="string">'Wage'</span>}, <span class="string">'progress='</span>, true);

format <span class="string">shortEng</span>;
disp(<span class="string">'Compare time-domain and frequency domain info matrices'</span>)
disp(<span class="string">'Time domain'</span>)
disp(F1)
disp(<span class="string">'Frequency domain'</span>)
disp(F2)

disp(<span class="string">'Compare diagonal elements'</span>)
[diag(F1), diag(F2)] <span class="comment">%#ok&lt;NOPTS&gt;</span>
format
</pre><pre class="codeoutput">Resample 100 times from calibrated model.
Compute Hessians for each draw and average them
Warning: IRIS Toolbox Warning
*** This name does not exist in input database: Wage
 
  In fisher_information_matrix (line 77)
  In evalmxdom&gt;instrumentAndRun (line 109)
  In evalmxdom (line 21)
  In publish
  In publish.mfile (line 3)

[--IRIS model.diffloglik progress--------]
[****************************************]

Compute information matrix in frequency domain

[--IRIS model.fisher progress------------]
[****************************************]

Compare time-domain and frequency domain info matrices
Time domain
  Columns 1 through 4

     1.3076e+003   119.4944e-003   -26.2029e-003  -793.9255e+000
   119.4944e-003   116.3329e-006    19.9577e-006  -148.1409e-003
   -26.2029e-003    19.9577e-006    72.5633e-006  -113.8339e-003
  -793.9255e+000  -148.1409e-003  -113.8339e-003     1.2420e+003
    18.2827e+000     4.3985e-003     3.9092e-003   -32.3710e+000
    57.6298e+000    12.7584e-003    34.4362e-003  -161.0231e+000
    12.6730e+003     1.4657e+000  -715.7922e-003    -1.3235e+003

  Columns 5 through 7

    18.2827e+000    57.6298e+000    12.6730e+003
     4.3985e-003    12.7584e-003     1.4657e+000
     3.9092e-003    34.4362e-003  -715.7922e-003
   -32.3710e+000  -161.0231e+000    -1.3235e+003
     1.0231e+000     4.2632e+000   -21.9555e+000
     4.2632e+000    35.3311e+000    -1.2127e+003
   -21.9555e+000    -1.2127e+003   970.2862e+003

Frequency domain
  Columns 1 through 4

     1.0873e+003    77.0003e-003   -14.7501e-003  -701.1530e+000
    77.0003e-003   113.6707e-006    25.7354e-006  -121.8888e-003
   -14.7501e-003    25.7354e-006    42.9864e-006   -61.8098e-003
  -701.1530e+000  -121.8888e-003   -61.8098e-003   966.6718e+000
    16.8336e+000     4.1748e-003     2.6464e-003   -27.3533e+000
    62.3300e+000    13.9524e-003    12.0337e-003  -104.3835e+000
     5.3613e+003    57.5725e-003   -66.9019e-003     1.0088e+003

  Columns 5 through 7

    16.8336e+000    62.3300e+000     5.3613e+003
     4.1748e-003    13.9524e-003    57.5725e-003
     2.6464e-003    12.0337e-003   -66.9019e-003
   -27.3533e+000  -104.3835e+000     1.0088e+003
   927.4078e-003     3.0535e+000   -53.0061e+000
     3.0535e+000    16.8948e+000  -827.5607e+000
   -53.0061e+000  -827.5607e+000   733.7568e+003

Compare diagonal elements

ans =

     1.3076e+003     1.0873e+003
   116.3329e-006   113.6707e-006
    72.5633e-006    42.9864e-006
     1.2420e+003   966.6718e+000
     1.0231e+000   927.4078e-003
    35.3311e+000    16.8948e+000
   970.2862e+003   733.7568e+003

</pre><h2 id="5">Singular Value Decomposition</h2><p>The singular value decomposition is a quick way how to find out which parameters or combinations of parameters are identified the best or the worst.</p><pre class="codeinput"><span class="comment">% TODO: Correct for the absolute size of the parameters.</span>

[u1, s1] = svd(F1);
[u2, s2] = svd(F2);

s1 = diag(s1);
s2 = diag(s2);
s1 = s1 / s1(1);
s2 = s2 / s2(1);

format <span class="string">shortEng</span>
disp(<span class="string">'Singular values (normalised and ordered)'</span>)
disp(<span class="string">'Time domain'</span>)
disp(s1.');
disp(<span class="string">'Frequency domain'</span>)
disp(s2.');

disp(<span class="string">'Combinations of parameters ordered by degree of identification'</span>)
disp(<span class="string">'Best identified columns ordered first'</span>)

disp(<span class="string">'Time domain'</span>)
[char(plist), num2str(u1, <span class="string">'| %-.2g'</span>)] <span class="comment">%#ok&lt;NOPTS&gt;</span>
disp(<span class="string">'Frequency domain'</span>)
[char(plist), num2str(u2, <span class="string">'| %-.2g'</span>)] <span class="comment">%#ok&lt;NOPTS&gt;</span>
format( );
</pre><pre class="codeoutput">Singular values (normalised and ordered)
Time domain
  Columns 1 through 4

     1.0000e+000     2.0448e-003   434.1277e-006    11.2797e-006

  Columns 5 through 7

   175.8676e-009    97.8851e-012    25.6592e-012

Frequency domain
  Columns 1 through 4

     1.0000e+000     2.3515e-003   408.6947e-006     6.4699e-006

  Columns 5 through 7

   187.1019e-009   132.3000e-012    31.9893e-012

Combinations of parameters ordered by degree of identification
Best identified columns ordered first
Time domain

ans =

  7x76 char array

    'chi   | -0.013  | -0.68   | 0.73    | -0.045  | -0.003  | 3.1e-06 | -6.6e-05'
    'xiw   | -1.5e-06| -8.9e-05| -6.2e-05| 0.0004  | -0.0035 | 0.99    | 0.17    '
    'xip   | 7.4e-07 | -3.8e-05| -0.00022| -0.0013 | -0.0046 | 0.17    | -0.99   '
    'rhor  | 0.0014  | 0.73    | 0.67    | -0.16   | -0.029  | 3.8e-05 | 0.00017 '
    'kappap| 2.2e-05 | -0.018  | -0.02   | 0.013   | -1      | -0.0042 | 0.0039  '
    'kappan| 0.0012  | -0.086  | -0.14   | -0.99   | -0.0081 | 0.00012 | 0.0014  '
    'std_Ey| -1      | 0.0098  | -0.0088 | -0.00086| -3.3e-05| -1.3e-06| 1.9e-06 '

Frequency domain

ans =

  7x76 char array

    'chi   | -0.0073 | -0.72   | 0.69    | -0.015   | -0.0052| 1.2e-05 | -7.8e-05'
    'xiw   | -7.9e-08| -8.1e-05| -0.00012| -0.00015 | -0.0048| 0.98    | 0.18    '
    'xip   | 9.1e-08 | -1.9e-05| -0.00018| -0.00093 | -0.004 | 0.18    | -0.98   '
    'rhor  | -0.0014 | 0.69    | 0.72    | -0.12    | -0.031 | -4e-05  | 8.2e-05 '
    'kappap| 7.2e-05 | -0.018  | -0.027  | -0.0039  | -1     | -0.0054 | 0.003   '
    'kappan| 0.0011  | -0.07   | -0.095  | -0.99    | 0.0077 | -0.00029| 0.00087 '
    'std_Ey| -1      | 0.0043  | -0.0061 | -0.00085 | 1.7e-05| -8.1e-07| 1.6e-06 '

</pre><h2 id="6">Variables and Objects Created in This File</h2><pre class="codeinput">whos
</pre><pre class="codeoutput">  Name          Size               Bytes  Class     Attributes

  F1            7x7                  392  double              
  F2            7x7                  392  double              
  F2i           7x7x21              8232  double              
  ans           7x76                1064  char                
  d             1x21                 168  double              
  m             1x1                90932  model               
  mloglik       1x100                800  double              
  numDraws      1x1                    8  double              
  plist         1x7                  846  cell                
  s             1x7x100             5600  double              
  s1            7x1                   56  double              
  s2            7x1                   56  double              
  u1            7x7                  392  double              
  u2            7x7                  392  double              

</pre><p class="footer"><br><a href="http://www.mathworks.com/products/matlab/">Published with MATLAB&reg; R2017b</a><br></p></div><!--
##### SOURCE BEGIN #####
%% Simulate Fisher Info Matrix and Test Parameter Identification
%
% Calculate estimates of the Fisher information matrix. The Fisher matrix
% is a property of the model itself, and is independent of any data. It
% represents the maximum amount of information one can hope for to find in
% the data in case the data are really generated by the model DGP.
%
% Compare two approaches: a time-domain approach, and a frequency-domain
% approach. Use the singular value decomposition to learn more about which
% parameters (or combinations of them) are identified the best or the
% worst.

%% Dependencies                                                            
%
% Run the following m-files before this one:
%
% * <read_model.html |read_model|>
%

%% Clear Workspace
%
% Clear workspace, close all graphics figures, clear command window, and
% check the IRIS version.

clear
close all
clc
irisrequired 20180131


%% Load Solved Model Object
%
% Load the solved model object built in |read_model|. 

load mat/read_model m


%% Calculate Fisher Information Matrix
%
% The Fisher information matrix is a useful tools examining how much
% information can be recovered from the data to identify some of the model
% parameters (under the assumption that the model with its current
% parameters is the true DGP).
%
% Compute the Fisher information matrix using two approaches:
% * a simulation method in the time domain.
% * an analytical method in the frequency domain.
%
% The results are asymptotically equivalent. The actual differencies
% observed in this exercise arise because of
%
% * sampling errors in the time domain, 
% * the fact that the frequency domain approach assumes that the model
% variables follow a circular process (which is not true for samples of
% finite lenthgs).
%
% The differences and other approximation errors are though usually
% immaterial for detecting identification deficiencies.

rng(0);

% List of parameters for which for which the Fisher matrix will be
% evaluated.
plist = {'chi', 'xiw', 'xip', 'rhor', 'kappap', 'kappan', 'std_Ey'};

% Set to a larger number in practice.
numDraws = 100;

fprintf('Resample %g times from calibrated model.\n', numDraws);

% Simulate a total of numDraws artificial data, length 40 periods.
d = resample(m, [ ], 1:40, numDraws, 'deviation=', false);
d = rmfield(d, 'Wage');

disp('Compute Hessians for each draw and average them')

[mloglik, s, F1] = diffloglik(m, d, 1:40, plist, ...
   'deviation=', true, 'relative=', false, 'progress=', true);

F1 = mean(F1, 3);

disp('Compute information matrix in frequency domain')
[F2, F2i, d] = fisher(m, 40, plist, ...
    'deviation=', false, 'exclude=', {'Wage'}, 'progress=', true);

format shortEng;
disp('Compare time-domain and frequency domain info matrices')
disp('Time domain')
disp(F1)
disp('Frequency domain')
disp(F2)

disp('Compare diagonal elements')
[diag(F1), diag(F2)] %#ok<NOPTS>
format

%% Singular Value Decomposition
%
% The singular value decomposition is a quick way how to find out which
% parameters or combinations of parameters are identified the best or the
% worst.

% TODO: Correct for the absolute size of the parameters.

[u1, s1] = svd(F1);
[u2, s2] = svd(F2);

s1 = diag(s1);
s2 = diag(s2);
s1 = s1 / s1(1);
s2 = s2 / s2(1);

format shortEng
disp('Singular values (normalised and ordered)')
disp('Time domain')
disp(s1.');
disp('Frequency domain')
disp(s2.');

disp('Combinations of parameters ordered by degree of identification')
disp('Best identified columns ordered first')

disp('Time domain')
[char(plist), num2str(u1, '| %-.2g')] %#ok<NOPTS>
disp('Frequency domain')
[char(plist), num2str(u2, '| %-.2g')] %#ok<NOPTS>
format( );

%% Variables and Objects Created in This File

whos


##### SOURCE END #####
--></body></html>