function Tests = parseEqtnsTest( )
Tests = functiontests(localfunctions);
end
%#ok<*DEFNU>




function testParseEqtns(this)
%{
Code>>>>>
'Label1' x{-10}=y{+10};
              a{-1}=b{-5};
c{2} = d{+3}
!!c =0;
   "'Label4';" e{t+2*10}=f{t-100-100}!!e=f;
    "Label Only" ;
    'Invalid Time Subscript' g{2*0}=0!!g=0;

"No Equal Sign" a+b+c+d+e+f+g;

'Multiple Labels 1' "Multiple Labels 2" "'Multiple Labels 3'"
j{+4}=2*j{t-4};
<<<<<Code
%}
TYPE = @int8;

b = parser.theparser.Equation( );
b.Type = TYPE(2);
code = parser.grabTextFromCaller('Code');
equation = model.Equation( );
quantity = model.Quantity( );
euc = parser.EquationUnderConstruction( );

q = warning('query');
expId = 'IRIS:TheParser:EmptyEquation';
warning('off', expId);
[~, equation] = parse(b, [ ], code, quantity, equation, euc, [ ], [ ]);
[~, actId] = lastwarn( );
assertEqual(this, actId, expId);
warning(q);

actInput = equation.Input;
expInput = { ...
    'x{-10}=y{+10};', ...
    'a{-1}=b{-5};', ...
    'c{2}=d{+3}!!c=0;', ...
    'e{t+2*10}=f{t-100-100}!!e=f;', ...
    'g{2*0}=0!!g=0;', ...
    'a+b+c+d+e+f+g;', ...
    'j{+4}=2*j{t-4};', ...
    };

actType = equation.Type;
expType = repmat(b.Type, 1, length(expInput));

actLabel = equation.Label;
expLabel = { ...
    'Label1', ...  
    '', ...
    '', ...
    '''Label4'';', ...
    'Invalid Time Subscript', ...
    'No Equal Sign', ...
    '''Multiple Labels 3''', ...
    };

actLhsDynamic = euc.LhsDynamic;
expLhsDynam = { ...
    'x{@-10}', ...
    'a{@-1}', ...
    'c{@+2}', ...
    'e{@+20}', ...
    'g', ...
    '', ...
    'j{@+4}', ...
    };

actRhsDynamic = euc.RhsDynamic;
expRhsDynam = { ...
    'y{@+10}', ...
    'b{@-5}', ...
    'd{@+3}', ...
    'f{@-200}', ...
    '0', ...
    'a+b+c+d+e+f+g', ...
    '2*j{@-4}', ...
    };

actSignDynamic = euc.SignDynamic;
expSignDynamic = { ...
    '=', ...
    '=', ...
    '=', ...
    '=', ...
    '=', ...
    '', ...
    '=', ...    
    };

actLhsSteady = euc.LhsSteady;
expLhsSteady = { ...
    '', ...
    '', ...
    'c', ...
    'e', ...
    'g', ...
    '', ...
    '', ...
    };

actRhsSteady = euc.RhsSteady;
expRhsSteady = { ...
    '', ...
    '', ...
    '0', ...
    'f', ...
    '0', ...
    '', ...
    '', ...
    };

actSignSteady = euc.SignSteady;
expSignSteady = { ...
    '', ...
    '', ...
    '=', ...
    '=', ...
    '=', ...
    '', ...
    '', ...
    };

actMaxSh = max(euc.MaxSh);
expMaxSh = 20;

actMinSh = min(euc.MinSh);
expMinSh = -200;

assertEqual(this, actInput, expInput);
assertEqual(this, actType, expType);
assertEqual(this, actLabel, expLabel);
assertEqual(this, actLhsDynamic, expLhsDynam);
assertEqual(this, actRhsDynamic, expRhsDynam);
assertEqual(this, actSignDynamic, expSignDynamic);
assertEqual(this, actLhsSteady, expLhsSteady);
assertEqual(this, actRhsSteady, expRhsSteady);
assertEqual(this, actSignSteady, expSignSteady);
assertEqual(this, actMaxSh, expMaxSh);
assertEqual(this, actMinSh, expMinSh);
end