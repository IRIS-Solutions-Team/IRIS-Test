%% Simulate Fisher Info Matrix and Test Parameter Identification
%
% Calculate estimates of the Fisher information matrix. The Fisher matrix
% is a property of the model itself, and is independent of any data. It
% represents the maximum amount of information one can hope for to find in
% the data in case the data are really generated by the model DGP.
%
% Compare two approaches: a time-domain approach, and a frequency-domain
% approach. Use the singular value decomposition to learn more about which
% parameters (or combinations of them) are identified the best or the
% worst.


%% Clear Workspace

close all
clear

load mat/createModel.mat m


%% Calculate Fisher Information Matrix
%
% The Fisher information matrix is a useful tools examining how much
% information can be recovered from the data to identify some of the model
% parameters (under the assumption that the model with its current
% parameters is the true DGP).
%
% Compute the Fisher information matrix using two approaches:
% * a simulation method in the time domain.
% * an analytical method in the frequency domain.
%
% The results are asymptotically equivalent. The actual differencies
% observed in this exercise arise because of
%
% * sampling errors in the time domain, 
% * the fact that the frequency domain approach assumes that the model
% variables follow a circular process (which is not true for samples of
% finite lenthgs).
%
% The differences and other approximation errors are though usually
% immaterial for detecting identification deficiencies.

rng(0);

% List of parameters for which for which the Fisher matrix will be
% evaluated.
plist = ["chi", "xiw", "xip", "rhor", "kappap", "kappan", "std_Ey"];

% Set to a larger number in practice.
numDraws = 100;

fprintf("Resample %g times from calibrated model.\n", numDraws);

% Simulate a total of numDraws artificial data, length 40 periods.
d = resample(m, [ ], 1:40, numDraws, "deviation", false);
d = rmfield(d, ["Wage", "Long"]);

disp("Compute Hessians for each draw and average them")

[mloglik, s, F1] = diffloglik(m, d, 1:40, plist, ...
   "deviation", true, "relative", false, "progress", true);

F1 = mean(F1, 3);

disp("Compute information matrix in frequency domain")
[F2, F2i, d] = fisher(m, 40, plist, ...
    "deviation", false, "exclude", ["Wage", "Long"], "progress", true);

format shortEng;
disp("Compare time-domain and frequency domain info matrices")
disp("Time domain")
disp(F1)
disp("Frequency domain")
disp(F2)

disp("Compare diagonal elements")
[diag(F1), diag(F2)] %#ok<NOPTS>
format


%% Singular Value Decomposition
%
% The singular value decomposition is a quick way how to find out which
% parameters or combinations of parameters are identified the best or the
% worst.

% TODO: Correct for the absolute size of the parameters

[u1, s1] = svd(F1);
[u2, s2] = svd(F2);

s1 = diag(s1);
s2 = diag(s2);
s1 = s1 / s1(1);
s2 = s2 / s2(1);

format shortEng
disp("Singular values (normalised and ordered)")
disp("Time domain")
disp(s1.');
disp("Frequency domain")
disp(s2.');

disp("Combinations of parameters ordered by degree of identification")
disp("Best identified columns ordered first")

disp("Time domain")
[char(plist'), num2str(u1, "| %-.2g")] %#ok<NOPTS>
disp("Frequency domain")
[char(plist'), num2str(u2, "| %-.2g")] %#ok<NOPTS>

format

